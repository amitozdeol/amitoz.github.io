<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://unpkg.com/sakura.css/css/sakura.css" type="text/css">
</head>
<body>
  <div id="app"><h1 id="allocate-memory">Allocate memory</h1>
<pre><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// When you define an int, float, or array, you define exactly how 
// much memory you need and that is all you can get at run time
// using traditional data types.

// If you need to allocate memory as a program runs you need 
// malloc()

// When malloc() is called you pass it the amount of memory required and
// it returns the address to that memory that you can refer to using 
// a pointer. If the space couldn&#39;t be found null is returned.


int main(){

    int amtOfNumbersToStore;

    printf(&quot;How many numbers do you want to store: &quot;);

    scanf(&quot;%d&quot;, &amp;amtOfNumbersToStore);

    // Create an int pointer and set aside enough space to hold the ints
    // required.
    // pRandomNumbers points to just the first element, but it can
    // access the others.
    // The typecast (int *) isn&#39;t required in C, but is in C++

    int * pRandomNumbers;
    pRandomNumbers = (int *) malloc(amtOfNumbersToStore * sizeof(int));

    // Check if memory was located by malloc

    if(pRandomNumbers != NULL){

        int i = 0;

        printf(&quot;Enter a Number or Quit: &quot;);

        // Receives ints until the memory allocated is full, or
        // until a non int is entered

        // You store values by referring to the pointer using
        // array notation

        while(i &lt; amtOfNumbersToStore &amp;&amp; scanf(&quot;%d&quot;, 
            &amp;pRandomNumbers[i]) == 1){

                printf(&quot;Enter a Number or Quit: &quot;);

                i++;

        }

        printf(&quot;\nYou entered the following numbers\n&quot;);

        // 

        for(int j = 0; j &lt; i; j++){

            printf(&quot;%d\n&quot;, pRandomNumbers[j]);

        }

    }

    // Make sure you give back the memory allocated by malloc
    // when you are finished with it.

    free(pRandomNumbers);

    // In this program free() isn&#39;t required because all allocated
    // memory is returned to the system when the program terminates.

    // free() would be required though if you were allocating large
    // blocks of memory over and over without returning it.

    // Let&#39;s say you store 10k of data using malloc, use it and have
    // no further use for it but don&#39;t use free.
    // Then you grab another 10k over and over. Eventually you&#39;ll
    // run out of memory and get a memory leak.

    return 0;
}
</code></pre>
<h2 id="allocate-structs-in-memory">Allocate structs in memory</h2>
<pre><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// struct that holds product information

struct product { 
    float price; 
    char productName[30]; 
}; 

int main(){ 

    // Pointer to a struct

    struct product *pProducts; 

    int i, j; 

    int numberOfProducts;

    printf(&quot;Enter the Number of Products to Store: &quot;); 

    // Dynamically we are defining how much space we need at run time

    scanf(&quot;%d&quot;,&amp;numberOfProducts); 

    // Allocates the memory required to store the structs
    // Type casting isn&#39;t needed for C, but is required for C++

    pProducts = (struct product *) malloc(numberOfProducts * 
        sizeof(struct product));

    for(i=0; i &lt; numberOfProducts; ++i){

        printf(&quot;Enter Product Name: &quot;);

        // This time I use pointer arithmetic to cycle through the data
        // and print it out

        scanf(&quot;%s&quot;, &amp;(pProducts+i)-&gt;productName);

        printf(&quot;Enter Product Price: &quot;);

        scanf(&quot;%f&quot;, &amp;(pProducts+i)-&gt;price);

    }

    printf(&quot;Products Stored\n&quot;); 

    for(j=0; j &lt; numberOfProducts; ++j){

        printf(&quot;%s\t%.2f\n&quot;, (pProducts+j)-&gt;productName, (pProducts+j)-&gt;price);

    }

    free(pProducts);

return 0; 
} 
</code></pre>
</div>
</body>
</html>